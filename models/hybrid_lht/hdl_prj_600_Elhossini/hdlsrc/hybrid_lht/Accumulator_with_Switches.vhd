-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj_600_Elhossini\hdlsrc\hybrid_lht\Accumulator_with_Switches.vhd
-- Created: 2020-03-05 10:35:23
-- 
-- Generated by MATLAB 9.7 and HDL Coder 3.15
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: Accumulator_with_Switches
-- Source Path: hybrid_lht/Hybrid LHT/Hybrid LHT Accumulator/Accumulator with Switches
-- Hierarchy Level: 2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.Hybrid_LHT_pkg.ALL;

ENTITY Accumulator_with_Switches IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        shift                             :   IN    vector_of_std_logic_vector6(0 TO 5);  -- ufix6 [6]
        hough_address                     :   IN    vector_of_std_logic_vector10(0 TO 5);  -- ufix10 [6]
        edge_rsvd                         :   IN    std_logic;
        mode                              :   IN    std_logic;
        read_address                      :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
        clear                             :   IN    std_logic;
        theta_index                       :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
        hps                               :   OUT   std_logic_vector(9 DOWNTO 0)  -- ufix10
        );
END Accumulator_with_Switches;


ARCHITECTURE rtl OF Accumulator_with_Switches IS

  -- Component Declarations
  COMPONENT Accumulator
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          shift                           :   IN    std_logic_vector(5 DOWNTO 0);  -- ufix6
          mode                            :   IN    std_logic;
          address                         :   IN    std_logic_vector(9 DOWNTO 0);  -- ufix10
          edge_rsvd                       :   IN    std_logic;
          hps                             :   OUT   std_logic_vector(9 DOWNTO 0)  -- ufix10
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : Accumulator
    USE ENTITY work.Accumulator(rtl);

  -- Signals
  SIGNAL theta_index_unsigned             : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Delay_out1                       : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL reduced_reg                      : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL mode_1                           : std_logic;
  SIGNAL switch_compare_1                 : std_logic;
  SIGNAL read_address_unsigned            : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Data_Type_Conversion_out1        : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL delayMatch1_reg                  : vector_of_unsigned10(0 TO 1);  -- ufix10 [2]
  SIGNAL Data_Type_Conversion_out1_1      : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Data_Type_Conversion_out1_scalarexpand : vector_of_unsigned10(0 TO 5);  -- ufix10 [6]
  SIGNAL hough_address_unsigned           : vector_of_unsigned10(0 TO 5);  -- ufix10 [6]
  SIGNAL Switch_out1                      : vector_of_unsigned10(0 TO 5);  -- ufix10 [6]
  SIGNAL Switch_out1_1                    : vector_of_std_logic_vector10(0 TO 5);  -- ufix10 [6]
  SIGNAL Multiport_Switch1_out1           : std_logic;
  SIGNAL reduced_reg_1                    : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL Multiport_Switch1_out1_1         : std_logic;
  SIGNAL delayMatch14_reg                 : vector_of_unsigned16(0 TO 1);  -- ufix16 [2]
  SIGNAL Delay_out1_1                     : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Accumulator_out1                 : vector_of_std_logic_vector10(0 TO 5);  -- ufix10 [6]
  SIGNAL Accumulator_out1_unsigned        : vector_of_unsigned10(0 TO 5);  -- ufix10 [6]
  SIGNAL Selector_out1                    : unsigned(9 DOWNTO 0);  -- ufix10

BEGIN
  theta_index_unsigned <= unsigned(theta_index);

  Delay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay_out1 <= to_unsigned(16#0000#, 16);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay_out1 <= theta_index_unsigned;
      END IF;
    END IF;
  END PROCESS Delay_process;


  reduced_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      reduced_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        reduced_reg(0) <= mode;
        reduced_reg(1) <= reduced_reg(0);
      END IF;
    END IF;
  END PROCESS reduced_process;

  mode_1 <= reduced_reg(1);

  
  switch_compare_1 <= '1' WHEN mode_1 > '0' ELSE
      '0';

  read_address_unsigned <= unsigned(read_address);

  Data_Type_Conversion_out1 <= read_address_unsigned(9 DOWNTO 0);

  delayMatch1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch1_reg <= (OTHERS => to_unsigned(16#000#, 10));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayMatch1_reg(0) <= Data_Type_Conversion_out1;
        delayMatch1_reg(1) <= delayMatch1_reg(0);
      END IF;
    END IF;
  END PROCESS delayMatch1_process;

  Data_Type_Conversion_out1_1 <= delayMatch1_reg(1);

  Data_Type_Conversion_out1_scalarexpand(0) <= Data_Type_Conversion_out1_1;
  Data_Type_Conversion_out1_scalarexpand(1) <= Data_Type_Conversion_out1_1;
  Data_Type_Conversion_out1_scalarexpand(2) <= Data_Type_Conversion_out1_1;
  Data_Type_Conversion_out1_scalarexpand(3) <= Data_Type_Conversion_out1_1;
  Data_Type_Conversion_out1_scalarexpand(4) <= Data_Type_Conversion_out1_1;
  Data_Type_Conversion_out1_scalarexpand(5) <= Data_Type_Conversion_out1_1;

  outputgen2: FOR k1 IN 0 TO 5 GENERATE
    hough_address_unsigned(k1) <= unsigned(hough_address(k1));
  END GENERATE;

  
  Switch_out1 <= Data_Type_Conversion_out1_scalarexpand WHEN switch_compare_1 = '0' ELSE
      hough_address_unsigned;

  outputgen1: FOR k1 IN 0 TO 5 GENERATE
    Switch_out1_1(k1) <= std_logic_vector(Switch_out1(k1));
  END GENERATE;

  
  Multiport_Switch1_out1 <= clear WHEN mode = '0' ELSE
      edge_rsvd;

  reduced_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      reduced_reg_1 <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        reduced_reg_1(0) <= Multiport_Switch1_out1;
        reduced_reg_1(1) <= reduced_reg_1(0);
      END IF;
    END IF;
  END PROCESS reduced_1_process;

  Multiport_Switch1_out1_1 <= reduced_reg_1(1);

  delayMatch14_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch14_reg <= (OTHERS => to_unsigned(16#0000#, 16));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayMatch14_reg(0) <= Delay_out1;
        delayMatch14_reg(1) <= delayMatch14_reg(0);
      END IF;
    END IF;
  END PROCESS delayMatch14_process;

  Delay_out1_1 <= delayMatch14_reg(1);

  GEN_LABEL: FOR k IN 0 TO 5 GENERATE
    u_Accumulator : Accumulator
      PORT MAP( clk => clk,
                reset => reset,
                enb => enb,
                shift => shift(k),  -- ufix6
                mode => mode_1,
                address => Switch_out1_1(k),  -- ufix10
                edge_rsvd => Multiport_Switch1_out1_1,
                hps => Accumulator_out1(k)  -- ufix10
                );
  END GENERATE;

  outputgen: FOR k IN 0 TO 5 GENERATE
    Accumulator_out1_unsigned(k) <= unsigned(Accumulator_out1(k));
  END GENERATE;

  
  Selector_out1 <= Accumulator_out1_unsigned(0) WHEN Delay_out1_1 = to_unsigned(16#0000#, 16) ELSE
      Accumulator_out1_unsigned(1) WHEN Delay_out1_1 = to_unsigned(16#0001#, 16) ELSE
      Accumulator_out1_unsigned(2) WHEN Delay_out1_1 = to_unsigned(16#0002#, 16) ELSE
      Accumulator_out1_unsigned(3) WHEN Delay_out1_1 = to_unsigned(16#0003#, 16) ELSE
      Accumulator_out1_unsigned(4) WHEN Delay_out1_1 = to_unsigned(16#0004#, 16) ELSE
      Accumulator_out1_unsigned(5);

  hps <= std_logic_vector(Selector_out1);

END rtl;

